import java.util.*;
import java.io.*;
import java.math.*;

/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/

class Order{

    public int id;
    public int[] ingredients;
    public int price;

    public Order(int id, int[] ingredients, int price){
        this.id = id;
        this.ingredients = ingredients;
        this.price = price;
    }

    public String output(){
        return "BREW " + this.id;
    }
}


class Spell{

    public int id;
    public int[] ingredients;
    public boolean castable;
    public boolean repeatable;

    public Spell(int id, int[] ingredients, boolean castable, boolean repeatable){
        this.id = id;
        this.ingredients = ingredients;
        this.castable = castable;
        this.repeatable = repeatable;
    }

    public String output(int times){
        return "CAST " + this.id + " " + times;
    }

    public void show(){
        System.err.println();
        System.err.println("id: " + id);
        System.err.println("ingredients: ");
        for(int i = 0; i < 4; i++){
            System.err.println();
            System.err.print(this.ingredients[i] + ", ");
        }
        System.err.println();
        System.err.println("castable: " + castable);
        System.err.println("repeatable: " + repeatable);
        System.err.println();
    }
}

class LearnSpell{

    public int id;
    public int[] ingredients;
    public int tomeIndex;
    public int taxCount;
    public boolean repeatable;

    public LearnSpell(int id, int[] ingredients, int tomeIndex, int taxCount, boolean repeatable){
        this.id = id;
        this.ingredients = ingredients;
        this.tomeIndex = tomeIndex;
        this.taxCount = taxCount;
        this.repeatable = repeatable;
    }

    public String output(){
        return "LEARN " + this.id;
    }

    public void show(){
        System.err.println();
        System.err.println("id: " + id);
        System.err.println("ingredients: ");
        for(int i = 0; i < 4; i++){
            System.err.println();
            System.err.print(this.ingredients[i] + ", ");
        }
        System.err.println();
        System.err.println("repeatable: " + repeatable);
        System.err.println("tomeIndex: " + tomeIndex);
        System.err.println("taxCount: " + taxCount);
        System.err.println();
    }
}


class State{

    public double score;
    public int[] ingredients;
    public BitSet spellsUsed;
    public BitSet ordersDeliverd;

    public int depth;
    public String command;

    public State(double score, int[] ingredients, BitSet spellsUsed, BitSet ordersDeliverd, String command, int depth){
        this.score = score;
        this.ingredients = ingredients;
        this.spellsUsed = spellsUsed;
        this.ordersDeliverd = ordersDeliverd;
        this.command = command;
        this.depth = depth;
    }


    public List<Order> canBrew(){
        List<Order> output = new ArrayList<Order>();

        for (Order order : Player.orders) {
            if(this.haveIngredients(order.ingredients)){
                output.add(order);
            }
            else{
                output.add(null);
            }
        }

        return output;
    }

    public boolean haveIngredients(int[] ingredients){
        for(int i = 0; i < 4; i++)
            if(ingredients[i] * -1 > this.ingredients[i])
                return false;
        return true;
    }


    public double evaluate(){
        double res = this.score + this.ingredients[0] * 0.1 + this.ingredients[1] * 0.2 + 
        this.ingredients[2] * 0.3 + this.ingredients[3] * 0.4;

        for (int i = 0; i < Player.mySpellsSize; i++) {
            if(this.spellsUsed.get(i)) res += 0.01;
        }

        // Math.pow(0.95, this.depth) * 

        return res;
    }

    public void show(){
        System.err.println();
        System.err.println("score: " + score);
        System.err.println("depth: " + depth);
        System.err.println("ingredients: ");
        for(int i = 0; i < 4; i++){
            System.err.print(this.ingredients[i] + ", ");
        }
        System.err.println();
        System.err.println();
        System.err.println("spellsUsed: ");
        for (int i = 0; i < Player.mySpellsSize; i++) {
            System.err.print(this.spellsUsed.get(i) + ", ");
        }
        System.err.println();
        System.err.println();
    }
}


class Sortbyroll implements Comparator<State>
{
    // Used for sorting in ascending order of
    // roll number
    public int compare(State a, State b)
    {
        double res = a.evaluate() - b.evaluate();
        if(res > 0) return -1;
        if(res < 0) return 1;
        return 0;
    }
}

class Player {


    public static  List<Order> orders;
    public static  List<Spell> mySpells;
    public static  List<Spell> opSpells;
    public static  List<LearnSpell> spellsToLearn;
    public static  int mySpellsSize;
    public static  int opSpellsSize;
    public static  int spellsToLearnSize = 6;

    public static List<Integer> spellsToLearnASAP = new ArrayList<Integer>();

    public static long startTime;
    public static int depth = 12;
    public static double[] values = {1, 2, 3, 4};

    public static int mone = 0;

    public static int N = 20;
    public static int learn = 10;
 
    public static int timeToEnd = 50;

    public static int ordersLeftToMe = 6;
    public static int ordersLeftToOpponent = 6;
    public static int prevOpponentScore = 0;
    public static int prevMyScore = 0;

    public static boolean haveBlueRep = false;
    public static boolean haveGreenRep = false;
    public static boolean haveOrangeRep = false;
    public static boolean haveYellowRep = false;

    public static List<State> states;

    public static void main(String args[]) {
        Scanner in = new Scanner(System.in);

        // game loop
        while (true) {
            orders = new ArrayList<Order>();
            mySpells = new ArrayList<Spell>();
            opSpells = new ArrayList<Spell>();
            spellsToLearn = new ArrayList<LearnSpell>();

            int actionCount = in.nextInt(); // the number of spells and recipes in play
            startTime = System.currentTimeMillis();
            for (int i = 0; i < actionCount; i++) {
                int actionId = in.nextInt(); // the unique ID of this spell or recipe
                String actionType = in.next(); // in the first league: BREW; later: CAST, OPPONENT_CAST, LEARN, BREW
                int delta0 = in.nextInt(); // tier-0 ingredient change
                int delta1 = in.nextInt(); // tier-1 ingredient change
                int delta2 = in.nextInt(); // tier-2 ingredient change
                int delta3 = in.nextInt(); // tier-3 ingredient change
                int price = in.nextInt(); // the price in rupees if this is a potion
                int tomeIndex = in.nextInt(); // in the first two leagues: always 0; later: the index in the tome if this is a tome spell, equal to the read-ahead tax; For brews, this is the value of the current urgency bonus
                int taxCount = in.nextInt(); // in the first two leagues: always 0; later: the amount of taxed tier-0 ingredients you gain from learning this spell; For brews, this is how many times you can still gain an urgency bonus
                boolean castable = in.nextInt() != 0; // in the first league: always 0; later: 1 if this is a castable player spell
                boolean repeatable = in.nextInt() != 0; // for the first two leagues: always 0; later: 1 if this is a repeatable player spell

                int[] ingredients = {delta0, delta1, delta2, delta3};
                
                if(actionType.equals("BREW")){
                    orders.add(new Order(actionId, ingredients, price));
                }
                else if(actionType.equals("CAST")){
                    if(repeatable && (!haveBlueRep || !haveGreenRep || !haveOrangeRep || !haveYellowRep)){
                        if(ingredients[0] < 0) haveBlueRep = true;
                        if(ingredients[1] < 0) haveGreenRep = true;
                        if(ingredients[2] < 0) haveOrangeRep = true;
                        if(ingredients[3] < 0) haveYellowRep = true;
                    }
                    mySpells.add(new Spell(actionId, ingredients, castable, repeatable));
                }
                else if(actionType.equals("OPPONENT_CAST")){
                    opSpells.add(new Spell(actionId, ingredients, castable, repeatable));
                }
                else if(actionType.equals("LEARN")){
                    spellsToLearn.add(new LearnSpell(actionId, ingredients, tomeIndex, taxCount, repeatable));
                }
            }

            State me = null, opponent = null;

            mySpellsSize = mySpells.size();
            opSpellsSize = opSpells.size();

            BitSet mySpellsUsed = new BitSet(mySpellsSize);

            for (int i = 0; i < mySpellsSize; i++) {
                Spell spell = mySpells.get(i);
                mySpellsUsed.set(i, !spell.castable);
            }

            for (int i = 0; i < 2; i++) {
                int inv0 = in.nextInt(); // tier-0 ingredients in inventory
                int inv1 = in.nextInt();
                int inv2 = in.nextInt();
                int inv3 = in.nextInt();
                int[] ingredients = {inv0, inv1, inv2, inv3};
                int score = in.nextInt(); // amount of rupees
                if(i == 0){
                    me = new State(0, ingredients, mySpellsUsed, new BitSet(5), "", 0);
                    if(score != prevMyScore){
                        prevMyScore = score;
                        ordersLeftToMe--;
                    }
                }
                else{
                    //opponent = new State(score, ingredients, new BitSet(opSpellsSize), new BitSet(spellsToLearnSize), new BitSet(spellsToLearnSize), new BitSet(5), "", 0);
                    if(score != prevOpponentScore){
                        prevOpponentScore = score;
                        ordersLeftToOpponent--;
                    }
                }
            }

            //System.err.println("me: ");
            //me.show();

            //System.err.println("opponent: ");
            //opponent.show();

            if(learn > 0){
                int ID = WhatLearn(me.ingredients[0]);
                if(ID != -1){
                    System.out.println("LEARN " + ID + " Hmm...");
                    learn--;
                    continue;
                }
            }


            states = new ArrayList<State>();
            mone = 0;
            String output = Sim(me);

            boolean hasLearn = false;

            for (Integer index : spellsToLearnASAP) {
                if(spellsToLearn.get(index).tomeIndex <= me.ingredients[0]){
                    hasLearn = true;
                    System.out.println(spellsToLearn.get(index).output());
                    break;
                }
            }

            if(hasLearn) continue;
            

            // Write an action using System.out.println()
            // To debug: System.err.println("Debug messages...");

            //System.out.println(output);
            // later: BREW <id> | CAST <id> [<times>] | LEARN <id> | REST | WAIT
            System.out.println(output);
        }
    }

    public static int WhatLearn(int numberOfBlues){

        int CanDoAChainReaction = 0;
        int BestId = -1;

        boolean HelpMeToHaveRepFromAllKinds = false;

        for(int i = 0; i < 6; i++){
            LearnSpell learnableSpell = spellsToLearn.get(i);
            if(learnableSpell.tomeIndex > numberOfBlues) continue;

            int[] inventoryGain = {0,0,0,0};
            int[] inventoryCost = {0,0,0,0};
            int sumCost = 0;

            for(int j = 0; j < 4; j++){
                if(learnableSpell.ingredients[j] > 0){
                    inventoryGain[j] = learnableSpell.ingredients[j];
                }
                else{
                    inventoryCost[j] = learnableSpell.ingredients[j];
                    sumCost += inventoryCost[j] * -1;
                }
            }

            //if(sumCost > 3) continue;

            for(int j = 0; j < mySpells.size(); j++){
                Spell mySpell = mySpells.get(j);
                if(mySpell.repeatable == false) continue;

                int[] SumInven1 = addIngredients(mySpell.ingredients, inventoryGain);
                for(int k = 0; k < 4; k++){
                    inventoryGain[k] *= 2;
                }
                int[] SumInven2 = addIngredients(mySpell.ingredients, inventoryGain);

                if(SumInven1 != null){
                    int[] sumInven = addIngredients(inventoryCost, SumInven1);
                    if(sumInven != null){

                        int s = 0;
                        for(int k = 0; k < 4; k++){
                            s += sumInven[k] * values[k];
                        }

                        //If it help me and better than prev if the prev also help me
                        //if it help me and prev is not so change it
                        if(((!haveBlueRep && inventoryCost[0] < 0) ||
                        (!haveGreenRep && inventoryCost[1] < 0) || 
                        (!haveOrangeRep && inventoryCost[2] < 0) || 
                        (!haveYellowRep && inventoryCost[3] < 0)) && (!HelpMeToHaveRepFromAllKinds || s > CanDoAChainReaction)){
                            s = CanDoAChainReaction;
                            BestId = learnableSpell.id;
                            HelpMeToHaveRepFromAllKinds = true;
                        }
                        else if(!HelpMeToHaveRepFromAllKinds && s > CanDoAChainReaction){
                            s = CanDoAChainReaction;
                            BestId = learnableSpell.id;
                        }
                        //if it doesn't help me but I didn't found something that help me
                        //and this is better than prev than change it
                    }
                }
                else if(SumInven2 != null){
                    int[] sumInven = addIngredients(inventoryCost, SumInven2);
                    if(sumInven != null){

                        int s = 0;
                        for(int k = 0; k < 4; k++){
                            s += sumInven[k] * values[k];
                        }

                        //If it help me and better than prev if the prev also help me
                        //if it help me and prev is not so change it
                        if(((!haveBlueRep && inventoryCost[0] < 0) ||
                        (!haveGreenRep && inventoryCost[1] < 0) || 
                        (!haveOrangeRep && inventoryCost[2] < 0) || 
                        (!haveYellowRep && inventoryCost[3] < 0)) && (!HelpMeToHaveRepFromAllKinds || s > CanDoAChainReaction)){
                            s = CanDoAChainReaction;
                            BestId = learnableSpell.id;
                            HelpMeToHaveRepFromAllKinds = true;
                        }
                        else if(!HelpMeToHaveRepFromAllKinds && s > CanDoAChainReaction){
                            s = CanDoAChainReaction;
                            BestId = learnableSpell.id;
                        }
                        //if it doesn't help me but I didn't found something that help me
                        //and this is better than prev than change it
                    }
                }
            }
        }

        if(BestId != -1){
            System.err.println("WhatLearn");
            return BestId;
        }

        return getIdLearn(numberOfBlues);
    }

    public static int getIdLearn(int numberOfBlues){

        int Max = -100;
        int BestId = -1;

        for(int i = 0; i < 6; i++){
            LearnSpell learnableSpell = spellsToLearn.get(i);

            if(learnableSpell.tomeIndex > numberOfBlues) continue;

            int gain = 0;
            int cost = 0;
            int sumCost = 0;

            for(int j = 0; j < 4; j++){
                if(learnableSpell.ingredients[j] < 0){
                    cost += learnableSpell.ingredients[j] * -1 * values[j];
                    sumCost += learnableSpell.ingredients[j] * -1;
                }
                else{
                    gain += learnableSpell.ingredients[j] * values[j];
                }
            }

            //if(sumCost > 4) continue;

            int diff = gain - cost;

            if(diff > Max){
                Max = diff;
                BestId = learnableSpell.id;
            }
        }

        return BestId;
    }

    public static String Sim(State state){

        Queue<State> que = new ArrayDeque<State>();
        que.add(state);
        states.add(state);
        
        double bestPrice = 0;
        State bestState = null;

        boolean start = true;

        int moneStates = 0;

        List<State> nextLevel = new ArrayList<State>();

        while(!que.isEmpty()){
            State currState = que.remove();
            moneStates++;
            

            if(System.currentTimeMillis() - startTime >= timeToEnd) break;

            //System.err.println("currState: ");
            //currState.show();

            //System.err.println("passed...");

            List<Order> ordersIcanDeliver = currState.canBrew();
            for (int i = 0; i < 5; i++) {
                Order order = ordersIcanDeliver.get(i);
                if(order == null) continue;
                String command = currState.command;
                if(start) command = order.output();

                BitSet ordersDeliverd = (BitSet) currState.ordersDeliverd.clone();
                ordersDeliverd.set(i);

                int[] newIngr = addIngredients(currState.ingredients, order.ingredients);

                State newState = new State(currState.score + order.price, newIngr, (BitSet) currState.spellsUsed.clone(),
                ordersDeliverd, command, currState.depth + 1);

                if(addToStates(newState)){
                    states.add(newState);
                    nextLevel.add(newState);
                }
            }

            double resEval = currState.evaluate();

            if(resEval > bestPrice){
                bestPrice = resEval;
                bestState = currState;
                
            }

            //CAST
            for (int i = 0; i < mySpellsSize; i++) {
                Spell spell = mySpells.get(i);
                String command = currState.command;
                if(currState.spellsUsed.get(i)){
                    if(start) command = "REST";
                    int[] newIngr = addIngredients(currState.ingredients, spell.ingredients);
                    while(newIngr != null){
                        BitSet spellsUsed = new BitSet(mySpellsSize);
                        spellsUsed.set(i);

                        State newState = new State(currState.score, newIngr, spellsUsed,
                        (BitSet) currState.ordersDeliverd.clone(), command, currState.depth + 2);
                        if(addToStates(newState)){
                            states.add(newState);
                            nextLevel.add(newState);
                        }

                        if(!spell.repeatable) break;

                        newIngr = addIngredients(newIngr, spell.ingredients);
                    }
                }
                else{
                    int times = 1;
                    int[] newIngr = addIngredients(currState.ingredients, spell.ingredients);
                    while(newIngr != null){
                        if(start) command = spell.output(times);

                        BitSet spellsUsed = (BitSet) currState.spellsUsed.clone();

                        spellsUsed.set(i);

                        State newState = new State(currState.score, newIngr, spellsUsed,
                        (BitSet) currState.ordersDeliverd.clone(), command, currState.depth + 1);
                        if(addToStates(newState)){
                            states.add(newState);
                            nextLevel.add(newState);
                        }

                        times++;

                        if(!spell.repeatable) break;

                        newIngr = addIngredients(newIngr, spell.ingredients);
                    }
                }
            }

            
            if(que.isEmpty()){
                Collections.sort(nextLevel, new Sortbyroll());

                for(int i = 0; i < Math.min(N, nextLevel.size()); i++){
                    que.add(nextLevel.get(i));
                }

                nextLevel = new ArrayList<State>();
            }

            start = false;
        }

        System.err.println();
        System.err.println("moneStates: " + moneStates);
        System.err.println("bestPrice: " + bestPrice);
        System.err.println();

        if(bestState == null) return randomAction(state);

        return bestState.command;
    }

    public static int[] addIngredients(int[] ingredients1, int[] ingredients2){
        int[] resIngr = new int[4];
        int mone = 0;

        for (int i = 0; i < 4; i++) {
            resIngr[i] = ingredients1[i] + ingredients2[i];
            if(resIngr[i] < 0) return null;
            mone += resIngr[i];
        }

        if(mone > 10) return null;
        return resIngr;
    }

    public static boolean addToStates(State state){
        //System.err.println("Test!");
        //System.err.println("state: ");
        //state.show();

        mone++;

        boolean pass = false;

        for (int i = states.size() - 1; i > -1; i--) {
            State st = states.get(i);

            boolean worseIngredients = true;
            boolean sameIngredients = true;
            boolean betterIngredients = true;

            //check ingredients
            for(int j = 0; j < 4; j++){
                if(st.ingredients[j] > state.ingredients[j]){
                    betterIngredients = false;
                    sameIngredients = false;
                }
                else if(st.ingredients[j] < state.ingredients[j]){
                    worseIngredients = false;
                    sameIngredients = false;
                }
            }

            if(sameIngredients){
                betterIngredients = false;
                worseIngredients = false;
            }

            boolean worseSpellsUsed = true;
            boolean sameSpellsUsed = true;
            boolean betterSpellsUsed = true;

            //check spellsUsed
            for(int j = 0; j < mySpellsSize; j++){
                if(st.spellsUsed.get(j) && state.spellsUsed.get(j) == false){
                    sameSpellsUsed = false;
                    worseSpellsUsed = false;
                }
                else if(st.spellsUsed.get(j) == false && state.spellsUsed.get(j)){
                    betterSpellsUsed = false;
                    sameSpellsUsed = false;
                }
            }

            if(sameSpellsUsed){
                betterSpellsUsed = false;
                worseSpellsUsed = false;
            }

            if(state.score <= st.score && state.depth >= st.depth && 
            ((worseIngredients && sameSpellsUsed) || (sameIngredients && worseSpellsUsed) ||
            (sameIngredients && sameSpellsUsed) || (worseIngredients && worseSpellsUsed))) {
                pass = false;
                break;
            }
            else if(state.score < st.score && state.depth == st.depth && ((sameIngredients && sameSpellsUsed) || (worseIngredients && worseSpellsUsed))) {
                pass = false;
                break;
            }
            else if(state.score == st.score && state.depth > st.depth && ((sameIngredients && sameSpellsUsed) || (worseIngredients && worseSpellsUsed))) {
                pass = false;
                break;
            }

            if((betterIngredients || betterSpellsUsed || (!sameSpellsUsed && !worseSpellsUsed) || (!sameIngredients && !worseIngredients)) && 
        	(!worseIngredients || !worseSpellsUsed)){
                pass = true;
            }
            else if(((sameSpellsUsed && sameIngredients)  || 
        		(sameIngredients && worseSpellsUsed) || 
        		(sameSpellsUsed && worseIngredients)) && (state.score > st.score || state.depth < st.depth)) {
                pass = true;
            }


            if(((betterIngredients && betterSpellsUsed) || (sameIngredients && sameSpellsUsed) 
            || (betterIngredients && sameSpellsUsed) || (sameIngredients && betterSpellsUsed)) && state.score >= st.score && state.depth <= st.depth){
                states.remove(i);
                //System.err.println("replace!");
                //System.err.println();
                /*System.err.println("state: ");
                state.show();
                System.err.println("st: ");
                st.show();*/
                //System.err.println("result 2: replace");
                //System.err.println();
                return true;
            }
            else if(sameSpellsUsed && sameIngredients && state.score >= st.score && state.depth <= st.depth) {
                states.remove(i);
                //System.err.println("replace 2!");
                //System.err.println();
                /*System.err.println("state: ");
                state.show();
                System.err.println("st: ");
                st.show();*/
                //System.err.println("result 2: replace");
                //System.err.println();
                return true;
            }
        }

        if(!pass){
            //System.err.println("result 2: don't add");
            //System.err.println();
            /*System.err.println("state: ");
            state.show();
            for (int i = states.size() - 1; i > -1; i--) {
                State st = states.get(i);
                System.err.println("st: ");
                st.show();
            }*/
            return pass;
        }

        //System.err.println("result 2: add");
        //System.err.println();

        return pass;
    }


    public static String randomAction(State state){
        List<String> commands = new ArrayList<String>();

        boolean rest = false;

        for(Spell spell : mySpells){
            if(!spell.castable){
                rest = true;
                continue;
            }
            int[] newIngr = addIngredients(state.ingredients, spell.ingredients);
            int times = 1;
            while(newIngr != null){
                String command = spell.output(times);
                commands.add(command);

                if(!spell.repeatable) break;

                times++;

                newIngr = addIngredients(newIngr, spell.ingredients);
            }
        }

        if(rest) commands.add("REST");

        int index = (int) Math.floor(Math.random() * commands.size());

        System.err.println("index: " + index);

        String com = commands.get(index);

        System.err.println("com: " + com);

        return com;
    }
}
