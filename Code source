import java.util.*;
import java.io.*;
import java.math.*;

/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/

class Order{

    public byte id;
    public byte[] ingredients;
    public byte price;

    public Order(byte id, byte[] ingredients, byte price){
        this.id = id;
        this.ingredients = ingredients;
        this.price = price;
    }

    public String output(){
        return "BREW " + this.id;
    }
}


class Spell{

    public byte id;
    public byte[] ingredients;
    public boolean castable;
    public boolean repeatable;

    public Spell(byte id, byte[] ingredients, boolean castable, boolean repeatable){
        this.id = id;
        this.ingredients = ingredients;
        this.castable = castable;
        this.repeatable = repeatable;
    }

    public String output(byte times){
        return "CAST " + this.id + " " + times;
    }

    public void show(){
        System.err.println();
        System.err.println("id: " + id);
        System.err.println("ingredients: ");
        for(byte i = 0; i < 4; i++){
            System.err.println();
            System.err.print(this.ingredients[i] + ", ");
        }
        System.err.println();
        System.err.println("castable: " + castable);
        System.err.println("repeatable: " + repeatable);
        System.err.println();
    }
}

class LearnSpell{

    public byte id;
    public byte[] ingredients;
    public byte tomeIndex;
    public byte taxCount;
    public boolean repeatable;

    public LearnSpell(byte id, byte[] ingredients, byte tomeIndex, byte taxCount, boolean repeatable){
        this.id = id;
        this.ingredients = ingredients;
        this.tomeIndex = tomeIndex;
        this.taxCount = taxCount;
        this.repeatable = repeatable;
    }

    public String output(){
        return "LEARN " + this.id;
    }
    public String output(byte times){
        return "CAST " + this.id + " " + times;
    }

    public void show(){
        System.err.println();
        System.err.println("id: " + id);
        System.err.println("ingredients: ");
        for(byte i = 0; i < 4; i++){
            System.err.println();
            System.err.print(this.ingredients[i] + ", ");
        }
        System.err.println();
        System.err.println("repeatable: " + repeatable);
        System.err.println("tomeIndex: " + tomeIndex);
        System.err.println("taxCount: " + taxCount);
        System.err.println();
    }
}


class State{

    public byte score;
    public double stateEval; 
    public byte[] ingredients;
    public BitSet spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed;

    public byte depth;
    public String command;

    public State(byte score, double parentEval, byte[] ingredients, BitSet spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed, String command, byte depth){
        this.score = score;
        this.ingredients = ingredients;
        this.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed = spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed;
        this.command = command;
        this.depth = depth;

        this.stateEval = this.evaluate();

        this.stateEval += parentEval;
    }


    public double evaluate(){
        double res = this.score + this.ingredients[0] + this.ingredients[1] * 2 + 
        this.ingredients[2] * 3 + this.ingredients[3] * 4;

        for (byte i = Player.startOrdersIndex; i < Player.startOrdersIndex + Player.ordersSize; i++) {
            if(this.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.get(i)) res += 1.1;
        }

        for (byte i = Player.startSpellsLearndIndex; i < Player.startSpellsLearndIndex + Player.spellsToLearnSize; i++) {
            if(this.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.get(i)) res += 0.5;
        }

        return Math.pow(0.95, this.depth) * res;
    }

    public void show(){
        System.err.println();
        System.err.println("score: " + score);
        System.err.println("depth: " + depth);
        System.err.println("ingredients: ");
        for(byte i = 0; i < 4; i++){
            System.err.print(this.ingredients[i] + ", ");
        }
        System.err.println();
        System.err.println();
    }
}


class Sortbyroll implements Comparator<State>
{
    // Used for sorting in ascending order of
    // roll number
    public int compare(State a, State b)
    {
        double res = a.stateEval - b.stateEval;
        if(res > 0) return -1;
        if(res < 0) return 1;
        return 0;
    }
}

class Player {

    public static List<Order> orders;
    public static List<Spell> mySpells;
    public static List<Spell> opSpells;
    public static List<LearnSpell> spellsToLearn;
    public static byte mySpellsSize;
    //public static byte opSpellsSize;
    public static byte spellsToLearnSize = 6;
    public static byte ordersSize = 5;

    public static byte startOrdersIndex;
    public static byte startSpellsLearndIndex;
    public static short startSpellsLearndUsedIndex;

    public static long startTime;
    //public static double[] values = {1, 2, 3, 4};

    //public static int mone = 0;

    public static byte N = 20;
    public static byte learn = 4;
 
    public static short timeToEnd = 1000;

    public static byte ordersLeftToMe = 6;
    public static byte ordersLeftToOpponent = 6;
    public static byte prevOpponentScore = 0;
    public static byte prevMyScore = 0;

    public static List<State> states;

    public static void main(String args[]) {
        Scanner in = new Scanner(System.in);

        // game loop
        while (true) {
            orders = new ArrayList<Order>();
            mySpells = new ArrayList<Spell>();
            //opSpells = new ArrayList<Spell>();
            spellsToLearn = new ArrayList<LearnSpell>();

            short actionCount = in.nextShort(); // the number of spells and recipes in play
            startTime = System.currentTimeMillis();
            for (byte i = 0; i < actionCount; i++) {
                byte actionId = in.nextByte(); // the unique ID of this spell or recipe
                String actionType = in.next(); // in the first league: BREW; later: CAST, OPPONENT_CAST, LEARN, BREW
                byte delta0 = in.nextByte(); // tier-0 ingredient change
                byte delta1 = in.nextByte(); // tier-1 ingredient change
                byte delta2 = in.nextByte(); // tier-2 ingredient change
                byte delta3 = in.nextByte(); // tier-3 ingredient change
                byte price = in.nextByte(); // the price in rupees if this is a potion
                byte tomeIndex = in.nextByte(); // in the first two leagues: always 0; later: the index in the tome if this is a tome spell, equal to the read-ahead tax; For brews, this is the value of the current urgency bonus
                byte taxCount = in.nextByte(); // in the first two leagues: always 0; later: the amount of taxed tier-0 ingredients you gain from learning this spell; For brews, this is how many times you can still gain an urgency bonus
                boolean castable = in.nextByte() != 0; // in the first league: always 0; later: 1 if this is a castable player spell
                boolean repeatable = in.nextByte() != 0; // for the first two leagues: always 0; later: 1 if this is a repeatable player spell

                byte[] ingredients = {delta0, delta1, delta2, delta3};
                
                if(actionType.equals("BREW")){
                    orders.add(new Order(actionId, ingredients, price));
                }
                else if(actionType.equals("CAST")){
                    mySpells.add(new Spell(actionId, ingredients, castable, repeatable));
                }
                /*else if(actionType.equals("OPPONENT_CAST")){
                    opSpells.add(new Spell(actionId, ingredients, castable, repeatable));
                }*/
                else if(actionType.equals("LEARN")){
                    spellsToLearn.add(new LearnSpell(actionId, ingredients, tomeIndex, taxCount, repeatable));
                }
            }

            State me = null;//, opponent = null;

            mySpellsSize = (byte) mySpells.size();
            //opSpellsSize = (byte) opSpells.size();

            BitSet spellsUsedAndOrdersDeliverdAndSpellsLearnd = new BitSet(mySpellsSize + ordersSize + spellsToLearnSize * 2);

            for (short i = 0; i < mySpellsSize; i++) {
                Spell spell = mySpells.get(i);
                spellsUsedAndOrdersDeliverdAndSpellsLearnd.set(i, !spell.castable);
            }

            for (short i = 0; i < 2; i++) {
                byte inv0 = in.nextByte(); // tier-0 ingredients in inventory
                byte inv1 = in.nextByte();
                byte inv2 = in.nextByte();
                byte inv3 = in.nextByte();
                byte[] ingredients = {inv0, inv1, inv2, inv3};
                byte score = in.nextByte(); // amount of rupees
                if(i == 0){
                    me = new State(score, 0, ingredients, spellsUsedAndOrdersDeliverdAndSpellsLearnd, "", (byte) 0);//new State(score, 0, ingredients, spellsUsedAndOrdersDeliverdAndSpellsLearnd, "", 0);
                    if(score != prevMyScore){
                        prevMyScore = score;
                        ordersLeftToMe--;
                    }
                }
                else{
                    //opponent = new State(score, ingredients, new BitSet(opSpellsSize), new BitSet(spellsToLearnSize), new BitSet(spellsToLearnSize), new BitSet(5), "", 0);
                    if(score != prevOpponentScore){
                        prevOpponentScore = score;
                        ordersLeftToOpponent--;
                    }
                }
            }

            startOrdersIndex = mySpellsSize;
            startSpellsLearndIndex = (byte) (startOrdersIndex + ordersSize);
            startSpellsLearndUsedIndex = (short) (startSpellsLearndIndex + spellsToLearnSize);

            //System.err.println("me: ");
            //me.show();

            //System.err.println("opponent: ");
            //opponent.show();

            if(learn > 0){
                if(timeToEnd == 1000){
                    //states = new ArrayList<State>();
                    //String output = SimWhatLearn(me);
                    timeToEnd = 50;
                    //learn--;
                    //System.out.println(output);
                    //continue;
                }
                byte ID = spellsToLearn.get(0).id;//WhatLearn(me.ingredients[0]);
                System.out.println("LEARN " + ID + " Hmm...");
                learn--;
                continue;
            }

            states = new ArrayList<State>();
            //mone = 0;
            String output = Sim(me);

            // Write an action using System.out.println()
            // To debug: System.err.println("Debug messages...");

            //System.out.println(output);
            // later: BREW <id> | CAST <id> [<times>] | LEARN <id> | REST | WAIT
            System.out.println(output);
        }
    }

    /*public static String SimWhatLearn(State state){

        Queue<State> que = new ArrayDeque<State>();
        states.add(state);
        
        double bestPrice = 0;
        State bestState = null;

        int moneStates = 0;
        int moneDepth = 0;

        List<State> nextLevel = new ArrayList<State>();

        //LEARN
        for (byte i = 0; i < spellsToLearnSize; i++) {
            LearnSpell spell = spellsToLearn.get(i);
            //Try to learn this spell
            if(spell.tomeIndex > state.ingredients[0]){
                //I don't have enough blues to pay for it
                continue;
            }

            byte[] newIngr = Arrays.copyOf(state.ingredients, 4);
            newIngr[0] -= spell.tomeIndex;
            if(isValid(newIngr) == 1){
                newIngr[0] += spell.taxCount;
                BitSet spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed = (BitSet) state.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clone();
                spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.set(i + startSpellsLearndIndex);
                    

                State newState = new State(state.score, state.stateEval, newIngr, spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed, 
                spell.output(), (byte) (state.depth + 1));

                byte isAdded = addToStates(newState);
                if(isAdded == 1){
                    nextLevel.add(newState);
                }
            }
        }


        Collections.sort(nextLevel, new Sortbyroll());

        int size = nextLevel.size();//(int) Math.round(nextLevel.size() * 0.7);
        int len = Math.min(N, size);

        for(byte i = 0; i < len; i++){
            que.add(nextLevel.get(i));
        }

        nextLevel = new ArrayList<State>();
        moneDepth++;


        while(!que.isEmpty()){
            State currState = que.remove();
            moneStates++;

            List<State> nextGen = nextStatesWhatToLearn(currState);
            
            if(System.currentTimeMillis() - startTime >= timeToEnd) break;

            if(!nextGen.isEmpty()){

                if(currState.stateEval > bestPrice){
                    bestPrice = currState.stateEval;
                    bestState = currState;
                }

                for(State st : nextGen){
                    nextLevel.add(st);
                }
            }


            if(que.isEmpty()){
                Collections.sort(nextLevel, new Sortbyroll());

                size = nextLevel.size();//(int) Math.round(nextLevel.size() * 0.7);
                len = Math.min(N, size);

                for(short i = 0; i < len; i++){
                    que.add(nextLevel.get(i));
                }

                nextLevel = new ArrayList<State>();
                moneDepth++;
            }
        }

        System.err.println();
        System.err.println("moneStates: " + moneStates);
        System.err.println("moneDepth: " + moneDepth);
        System.err.println("bestPrice: " + bestPrice);
        System.err.println();

        if(bestState == null) return randomAction(state);

        return bestState.command;
    }

    public static List<State> nextStatesWhatToLearn(State currState){

        List<State> result = new ArrayList<State>();

        String command = currState.command;

        for (byte i = 0; i < ordersSize; i++) {
            Order order = orders.get(i);
            if(currState.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.get(i + startOrdersIndex)) continue;
            byte[] newIngr = addIngredients(currState.ingredients, order.ingredients);
            if(newIngr != null){
                BitSet spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed = (BitSet) currState.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clone();
                spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.set(i + startOrdersIndex);

                State newState = new State((byte) (currState.score + order.price), currState.stateEval, newIngr, spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed, 
                command, (byte) (currState.depth + 1));

                byte isAdded = addToStates(newState);
                if(isAdded == 1){
                    result.add(newState);
                }
            }
        }

        //CAST
        for (byte i = 0; i < mySpellsSize; i++) {
            Spell spell = mySpells.get(i);
            if(currState.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.get(i)){
                byte[] newIngr = addIngredients(currState.ingredients, spell.ingredients);
                double times = 0;
                while(newIngr != null){
                    BitSet spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed = (BitSet) currState.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clone();
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clear(0, mySpellsSize);
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clear(startSpellsLearndUsedIndex, startSpellsLearndUsedIndex + spellsToLearnSize);
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.set(i);

                    State newState = new State(currState.score, currState.stateEval + times, newIngr, spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed, 
                    command, (byte) (currState.depth + 2));

                    byte isAdded = addToStates(newState);
                    if(isAdded == 1){
                        result.add(newState);
                    }

                    if(!spell.repeatable) break;

                    times = 0.1;

                    newIngr = addIngredients(newIngr, spell.ingredients);
                }
            }
            else{
                byte[] newIngr = addIngredients(currState.ingredients, spell.ingredients);
                double times = 0;
                while(newIngr != null){
                    BitSet spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed = (BitSet) currState.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clone();
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.set(i);

                    State newState = new State(currState.score, currState.stateEval + times, newIngr, spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed, 
                    command, (byte) (currState.depth + 1));

                    byte isAdded = addToStates(newState);
                    if(isAdded == 1){
                        result.add(newState);
                    }

                    if(!spell.repeatable) break;

                    times = 0.1;

                    newIngr = addIngredients(newIngr, spell.ingredients);
                }
            }
        }

        //LEARN
        for (byte i = 0; i < spellsToLearnSize; i++) {
            LearnSpell spell = spellsToLearn.get(i);
            if(!currState.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.get(i + startSpellsLearndIndex)) continue;
            if(currState.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.get(i + startSpellsLearndUsedIndex)){
                byte[] newIngr = addIngredients(currState.ingredients, spell.ingredients);
                double times = 0;
                while(newIngr != null){
                    BitSet spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed = (BitSet) currState.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clone();
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clear(0, mySpellsSize);
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clear(startSpellsLearndUsedIndex, startSpellsLearndUsedIndex + spellsToLearnSize);
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.set(i + startSpellsLearndUsedIndex);

                    State newState = new State(currState.score, currState.stateEval + times, newIngr, spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed, 
                    command, (byte) (currState.depth + 2));

                    byte isAdded = addToStates(newState);
                    if(isAdded == 1){
                        result.add(newState);
                    }

                    if(!spell.repeatable) break;

                    times = 0.1;

                    newIngr = addIngredients(newIngr, spell.ingredients);
                }
            }
            else{
                byte[] newIngr = addIngredients(currState.ingredients, spell.ingredients);
                double times = 0;
                while(newIngr != null){
                    BitSet spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed = (BitSet) currState.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clone();
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.set(i + startSpellsLearndUsedIndex);

                    State newState = new State(currState.score, currState.stateEval + times, newIngr, spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed, 
                    command, (byte) (currState.depth + 1));

                    byte isAdded = addToStates(newState);
                    if(isAdded == 1){
                        result.add(newState);
                    }

                    if(!spell.repeatable) break;

                    times = 0.1;

                    newIngr = addIngredients(newIngr, spell.ingredients);
                }
            }
        }

        return result;
    }*/

    public static String Sim(State state){

        Queue<State> que = new ArrayDeque<State>();
        states.add(state);
        
        double bestPrice = 0;
        State bestState = null;

        int moneStates = 0;
        int moneDepth = 0;

        List<State> nextLevel = new ArrayList<State>();

        for (byte i = 0; i < ordersSize; i++) {
            Order order = orders.get(i);
            byte[] newIngr = addIngredients(state.ingredients, order.ingredients);
            if(newIngr != null){
                BitSet spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed = (BitSet) state.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clone();
                spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.set(i + startOrdersIndex);

                State newState = new State((byte) (state.score + order.price), state.stateEval, newIngr, spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed, 
                order.output(), (byte) (state.depth + 1));

                byte isAdded = addToStates(newState);

                if(isAdded == 1){
                    if(ordersLeftToMe == 1){
                        if(newState.score > prevOpponentScore && newState.score > bestPrice){
                            bestPrice = newState.score;
                            bestState = newState;
                        }
                    }
                    else{
                        nextLevel.add(newState);
                    }
                }
            }
        }

        if(bestPrice != 0){
            /*System.err.println();
            System.err.println("moneStates: " + moneStates);
            System.err.println("moneDepth: " + moneDepth);
            System.err.println("bestPrice: " + bestPrice);
            System.err.println();*/
            return bestState.command;
        }

        //CAST
        for (byte i = 0; i < mySpellsSize; i++) {
            Spell spell = mySpells.get(i);
            if(state.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.get(i)){
                byte[] newIngr = addIngredients(state.ingredients, spell.ingredients);
                double times = 0;
                while(newIngr != null){
                    BitSet spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed = (BitSet) state.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clone();
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clear(0, mySpellsSize);
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.set(i);

                    State newState = new State(state.score, state.stateEval + times, newIngr, spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed, 
                    "REST", (byte) (state.depth + 2));

                    byte isAdded = addToStates(newState);
                    if(isAdded == 1){
                        nextLevel.add(newState);
                    }

                    if(!spell.repeatable) break;

                    times = 0.1;

                    newIngr = addIngredients(newIngr, spell.ingredients);
                }
            }
            else{
                byte times = 1;
                byte[] newIngr = addIngredients(state.ingredients, spell.ingredients);
                double addTimes = 0;
                while(newIngr != null){

                    BitSet spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed = (BitSet) state.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clone();
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.set(i);

                    State newState = new State(state.score, state.stateEval + addTimes, newIngr, spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed, 
                    spell.output(times), (byte) (state.depth + 1));

                    byte isAdded = addToStates(newState);
                    if(isAdded == 1){
                        nextLevel.add(newState);
                    }

                    if(!spell.repeatable) break;

                    times++;

                    addTimes = 0.1;

                    newIngr = addIngredients(newIngr, spell.ingredients);
                }
            }
        }

        //LEARN
        for (byte i = 0; i < spellsToLearnSize; i++) {
            LearnSpell spell = spellsToLearn.get(i);
            //Try to learn this spell
            if(spell.tomeIndex > state.ingredients[0]){// || !spell.repeatable){
                //I don't have enough blues to pay for it
                continue;
            }

            byte[] newIngr = Arrays.copyOf(state.ingredients, 4);
            newIngr[0] -= spell.tomeIndex;
            if(isValid(newIngr) == 1){
                newIngr[0] += spell.taxCount;
                newIngr = addIngredients(newIngr, spell.ingredients);
                double addTimes = 0;
                while(newIngr != null){
                    BitSet spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed = (BitSet) state.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clone();
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.set(i + startSpellsLearndIndex);
                    
                    State newState = new State(state.score, state.stateEval + addTimes, newIngr, spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed, 
                    spell.output(), (byte) (state.depth + 2));

                    byte isAdded = addToStates(newState);
                    if(isAdded == 1){
                        nextLevel.add(newState);
                    }

                    if(!spell.repeatable) break;

                    addTimes = 0.1;

                    newIngr = addIngredients(newIngr, spell.ingredients);
                }
            }
        }


        Collections.sort(nextLevel, new Sortbyroll());

        int size = nextLevel.size();//(int) Math.round(nextLevel.size() * 0.7);
        int len = Math.min(N, size);

        for(byte i = 0; i < len; i++){
            que.add(nextLevel.get(i));
        }

        nextLevel = new ArrayList<State>();
        moneDepth++;


        while(!que.isEmpty()){
            State currState = que.remove();
            moneStates++;

            List<State> nextGen = nextStates(currState);
            
            if(System.currentTimeMillis() - startTime >= timeToEnd) break;

            if(!nextGen.isEmpty()){

                if(currState.stateEval > bestPrice){
                    bestPrice = currState.stateEval;
                    bestState = currState;
                }

                for(State st : nextGen){
                    nextLevel.add(st);
                }
            }


            if(que.isEmpty()){
                Collections.sort(nextLevel, new Sortbyroll());

                size = nextLevel.size();//(int) Math.round(nextLevel.size() * 0.7);
                len = Math.min(N, size);

                for(short i = 0; i < len; i++){
                    que.add(nextLevel.get(i));
                }

                nextLevel = new ArrayList<State>();
                moneDepth++;
            }
        }

        /*System.err.println();
        System.err.println("moneStates: " + moneStates);
        System.err.println("moneDepth: " + moneDepth);
        System.err.println("bestPrice: " + bestPrice);
        System.err.println();*/

        if(bestState == null) return randomAction(state);

        return bestState.command;
    }

    public static byte[] addIngredients(byte[] ingredients1, byte[] ingredients2){
        byte[] resIngr = new byte[4];
        byte mone = 0;

        for (byte i = 0; i < 4; i++) {
            resIngr[i] = ingredients1[i];
            resIngr[i] += ingredients2[i];
            if(resIngr[i] < 0) return null;
            mone += resIngr[i];
        }

        if(mone > 10) return null;
        return resIngr;
    }

    public static byte isValid(byte[] ingredients){
        byte mone = 0;

        for (byte i = 0; i < 4; i++) {
            if(ingredients[i] < 0) return 0;
            mone += ingredients[i];
        }

        if(mone > 10) return 0;
        return 1;
    }

    public static byte addToStates(State state){

        //mone++;

        byte pass = 0;

        byte worseIngredients = 1, sameIngredients = 1, betterIngredients = 1;
        byte worseSpellsUsed = 1, sameSpellsUsed = 1, betterSpellsUsed = 1;
        byte worseSpellsLearndUsed = 1, sameSpellsLearndUsed = 1, betterSpellsLearndUsed = 1;

        for (short i = (short) (states.size() - 1); i > -1; i--) {
            State st = states.get(i);

            worseIngredients = 1;
            sameIngredients = 1;
            betterIngredients = 1;
            worseSpellsUsed = 1;
            sameSpellsUsed = 1;
            betterSpellsUsed = 1;
            worseSpellsLearndUsed = 1;
            sameSpellsLearndUsed = 1;
            betterSpellsLearndUsed = 1;

            //check ingredients
            for(byte j = 0; j < 4; j++){
                if(st.ingredients[j] > state.ingredients[j]){
                    betterIngredients = 0;
                    sameIngredients = 0;
                }
                else if(st.ingredients[j] < state.ingredients[j]){
                    worseIngredients = 0;
                    sameIngredients = 0;
                }
            }

            if(sameIngredients == 1){
                betterIngredients = 0;
                worseIngredients = 0;
            }

            //check spellsUsed
            for(byte j = 0; j < mySpellsSize; j++){
                if(st.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.get(j) && state.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.get(j) == false){
                    sameSpellsUsed = 0;
                    worseSpellsUsed = 0;
                }
                else if(st.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.get(j) == false && state.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.get(j)){
                    betterSpellsUsed = 0;
                    sameSpellsUsed = 0;
                }
            }

            if(sameSpellsUsed == 1){
                betterSpellsUsed = 0;
                worseSpellsUsed = 0;
            }

            //check spellLearndUsed
            for(byte j = startSpellsLearndIndex; j < spellsToLearnSize + startSpellsLearndIndex; j++){
                if(st.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.get(j) == false && state.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.get(j)){
                    sameSpellsLearndUsed = 0;
                    worseSpellsLearndUsed = 0;
                }
                else if(st.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.get(j) && state.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.get(j) == false){
                    betterSpellsLearndUsed = 0;
                    sameSpellsLearndUsed = 0;
                }
            }

            if(sameSpellsLearndUsed == 1){
                betterSpellsLearndUsed = 0;
                worseSpellsLearndUsed = 0;
            }

            if(state.score <= st.score && state.depth >= st.depth &&
            ((sameIngredients == 1 && sameSpellsUsed == 1 && sameSpellsLearndUsed == 1)  || 
            (sameIngredients == 1 && sameSpellsUsed == 1 && worseSpellsLearndUsed == 1)  || 
            (sameIngredients == 1 && worseSpellsUsed == 1 && sameSpellsLearndUsed == 1) || 
            (sameIngredients == 1 && worseSpellsUsed == 1 && worseSpellsLearndUsed == 1) ||
            (worseIngredients == 1 && sameSpellsUsed == 1 && sameSpellsLearndUsed == 1) ||
            (worseIngredients == 1 && sameSpellsUsed == 1 && worseSpellsLearndUsed == 1) ||
            (worseIngredients == 1 && worseSpellsUsed == 1 && sameSpellsLearndUsed == 1) ||
            (worseIngredients == 1 && worseSpellsUsed == 1 && worseSpellsLearndUsed == 1))) {
                return 0;
            }

            if(betterIngredients == 1 || betterSpellsUsed == 1 || betterSpellsLearndUsed == 1 || 
            (worseSpellsLearndUsed == 0 && sameSpellsLearndUsed == 0 && betterSpellsLearndUsed == 0) ||
            (worseSpellsUsed == 0 && sameSpellsUsed == 0 && betterSpellsUsed == 0) || 
            (worseIngredients == 0 && sameIngredients == 0 && betterIngredients == 0)){
                pass = 1;
            }
            else if(((sameIngredients == 1 && sameSpellsUsed == 1 && sameSpellsLearndUsed == 1)  || 
                    (sameIngredients == 1 && sameSpellsUsed == 1 && worseSpellsLearndUsed == 1)  || 
                    (sameIngredients == 1 && worseSpellsUsed == 1 && sameSpellsLearndUsed == 1) || 
                    (sameIngredients == 1 && worseSpellsUsed == 1 && worseSpellsLearndUsed == 1) ||
                    (worseIngredients == 1 && sameSpellsUsed == 1 && sameSpellsLearndUsed == 1) ||
                    (worseIngredients == 1 && sameSpellsUsed == 1 && worseSpellsLearndUsed == 1) ||
                    (worseIngredients == 1 && worseSpellsUsed == 1 && sameSpellsLearndUsed == 1) ||
                    (worseIngredients == 1 && worseSpellsUsed == 1 && worseSpellsLearndUsed == 1)) && (state.score > st.score || state.depth < st.depth)) {
                pass = 1;
            }
                //0 0 1
            if(((sameIngredients == 1 && sameSpellsUsed == 1 && betterSpellsLearndUsed == 1) ||
                //0 1 0
                (sameIngredients == 1 && betterSpellsUsed == 1 && sameSpellsLearndUsed == 1) ||
                //0 1 1
                (sameIngredients == 1 && betterSpellsUsed == 1 && betterSpellsLearndUsed == 1) ||
                //1 0 0
                (betterIngredients == 1 && sameSpellsUsed == 1 && sameSpellsLearndUsed == 1) ||
                //1 0 1
                (betterIngredients == 1 && sameSpellsUsed == 1 && betterSpellsLearndUsed == 1) ||
                //1 1 0
                (betterIngredients == 1 && betterSpellsUsed == 1 && sameSpellsLearndUsed == 1) ||
                //1 1 1
                (betterIngredients == 1 && betterSpellsUsed == 1 && betterSpellsUsed == 1))
                && state.score >= st.score && state.depth <= st.depth){
                states.set(i, state);
                return 1;
            }
        }

        if(pass == 1){
            states.add(state);
        }

        return pass;
    }

    public static String randomAction(State state){
        List<String> commands = new ArrayList<String>();

        byte rest = 0;

        for(Spell spell : mySpells){
            if(!spell.castable){
                rest = 1;
                continue;
            }
            byte[] newIngr = addIngredients(state.ingredients, spell.ingredients);
            byte times = 1;
            while(newIngr != null){
                String command = spell.output(times);
                commands.add(command);

                if(!spell.repeatable) break;

                times++;

                newIngr = addIngredients(newIngr, spell.ingredients);
            }
        }

        if(rest == 1) commands.add("REST");

        int index = (int) Math.floor(Math.random() * commands.size());

        //System.err.println("index: " + index);

        String com = commands.get(index);

        //System.err.println("com: " + com);

        return com;
    }


    public static List<State> nextStates(State currState){
        List<State> result = new ArrayList<State>();

        String command = currState.command;

        for (byte i = 0; i < ordersSize; i++) {
            Order order = orders.get(i);
            if(currState.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.get(i + startOrdersIndex)) continue;
            byte[] newIngr = addIngredients(currState.ingredients, order.ingredients);
            if(newIngr != null){
                BitSet spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed = (BitSet) currState.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clone();
                spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.set(i + startOrdersIndex);

                State newState = new State((byte) (currState.score + order.price), currState.stateEval, newIngr, spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed, 
                command, (byte) (currState.depth + 1));

                byte isAdded = addToStates(newState);
                if(isAdded == 1){
                    result.add(newState);
                }
            }
        }

        //CAST
        for (byte i = 0; i < mySpellsSize; i++) {
            Spell spell = mySpells.get(i);
            if(currState.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.get(i)){
                byte[] newIngr = addIngredients(currState.ingredients, spell.ingredients);
                double times = 0;
                while(newIngr != null){
                    BitSet spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed = (BitSet) currState.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clone();
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clear(0, mySpellsSize);
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clear(startSpellsLearndUsedIndex, startSpellsLearndUsedIndex + spellsToLearnSize);
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.set(i);

                    State newState = new State(currState.score, currState.stateEval + times, newIngr, spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed, 
                    command, (byte) (currState.depth + 2));

                    byte isAdded = addToStates(newState);
                    if(isAdded == 1){
                        result.add(newState);
                    }

                    if(!spell.repeatable) break;

                    times = 0.1;

                    newIngr = addIngredients(newIngr, spell.ingredients);
                }
            }
            else{
                byte[] newIngr = addIngredients(currState.ingredients, spell.ingredients);
                double times = 0;
                while(newIngr != null){
                    BitSet spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed = (BitSet) currState.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clone();
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.set(i);

                    State newState = new State(currState.score, currState.stateEval + times, newIngr, spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed, 
                    command, (byte) (currState.depth + 1));

                    byte isAdded = addToStates(newState);
                    if(isAdded == 1){
                        result.add(newState);
                    }

                    if(!spell.repeatable) break;

                    times = 0.1;

                    newIngr = addIngredients(newIngr, spell.ingredients);
                }
            }
        }

        //LEARN
        for (byte i = 0; i < spellsToLearnSize; i++) {
            LearnSpell spell = spellsToLearn.get(i);
            if(currState.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.get(i + startSpellsLearndIndex)){
                byte[] newIngr = addIngredients(currState.ingredients, spell.ingredients);
                double times = 0;
                while(newIngr != null){
                    BitSet spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed = (BitSet) currState.spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clone();
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clear(0, mySpellsSize);
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.clear(startSpellsLearndUsedIndex, startSpellsLearndUsedIndex + spellsToLearnSize);
                    spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed.set(i + startSpellsLearndUsedIndex);

                    State newState = new State(currState.score, currState.stateEval + times, newIngr, spellsUsedAndOrdersDeliverdAndSpellsLearndAndSpellsLearndUsed, 
                    command, (byte) (currState.depth + 2));

                    byte isAdded = addToStates(newState);
                    if(isAdded == 1){
                        result.add(newState);
                    }

                    if(!spell.repeatable) break;

                    times = 0.1;

                    newIngr = addIngredients(newIngr, spell.ingredients);
                }
            }
        }

        return result;
    }
}
